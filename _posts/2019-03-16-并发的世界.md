---
layout:     post
title:      并发的世界
subtitle:   初探并发的世界
date:       2019-03-16
author:     HDD
header-img: img/post_bg_shell.png
catalog: true
tags:
    - 并发
--

# 前言
工作当中有很多机会是尝试使用并发的场景,但是由于自己并发的知识掌握的并不充足,所以打算加强学习一下,争取早日应用到线上.

## 初探并发世界

### 专业词汇

* **同步**:同步调用,调用方会阻塞的等待被调用方返回结果.
* **异步**:异步调用,调用方类似向被调用方发送了一个消息(干活),调用方不会阻塞的一直等待被调用方,而会继续做自己的事.
* **并行**:多件事真的一起在执行
* **并发**:多件事交替的执行
* **临界区**:公共资源,但是每次只允许一个线程占用
* **阻塞**:指多个线程抢占临界区资源,当临界区资源被抢占,其他线程就只能陷入到阻塞状态.
* **非阻塞**:强调没有一个线程可以妨碍其他线程的执行
* **死锁**:最简单的死锁,A线程等B线程,B等待C,C等待A
* **饥饿**:指一个或多个线程因为种种原因(例:优先级低)而一直无法执行
* **活锁**:当两个线程互相谦让,而导致双方都无法执行
  
### 并发级别
由于临界区的存在,多线程之间的并发必须受到控制.根据控制并发的策略,我们可以把并发的级别进行分类,大致可分为**阻塞**、**无饥饿**、**无锁**、**无等待**等.

**阻塞**:当临界区资源被释放之前,当前线程都无法执行.可以使用synchronized | 重入锁来实现,(悲观)

**无饥饿**:当莫个线程等优先级很低,不断的被其他高优先级的优先级‘插队’,那么该线程会一直无法得到执行,一直处于饥饿状态.

**无障碍**:无障碍是一种很弱等非阻塞调度方式.多个线程要是无障碍的执行,那么他们同时进入临界区,当检测到有其他线程修改了共享变量,当前线程做的修改就会回滚.可以使用`一致性标记`来实现,(乐观)
  
**无锁**:无锁是无障碍的一种,无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区

**无等待**:无等待是无锁的一种,无等待要求所有的线程都必须在有限步内完

### 并行中两个比较重要的定律
* **Amdahl定律**
* **Gustafson定律**

### Java : JMM
并发程序在数据访问的一致性和安全性都是一个问题,而JMM也就是为了这类问题而生的

JMM的关键技术点都是围绕着多线程的原子性、可见性、有序性来建立的

**原子性**:指一个操作是不可中断的,即使在多线程的环境下,一个操作一旦开始,就不会受到其他线程干扰

**可见性**:一个线程修改了莫一个共享变量的值,其他线程是否能够立即知道这个修改

**有序性**:






























---
layout:     post
title:      Shell学习
subtitle:   shell学习之路
date:       2019-01-01
author:     HDD
header-img: img/post_bg_shell.png
catalog: true
tags:
    - shell
---

# 前言
在前段时间工作都时候，因为公司测试环境需要测试其他模块，而我这一块的功能由于默写原因不能合并到里面。所以我需要自己在服务器上搭建一套测试环境，开始接触到了shell，之前也用过ubuntu做为过个人操作系统，但是并没有系统的学习过Linux和shell（虽然学校教过），所以在这里记录一下自己学习shell的心得。

### Linux系统启动流程
* 第一步：首先BIOS系统会加电自检（主要检查硬件有没有问题），然后BIOS系统会引导系统，BIOS默认回从硬盘上的第0柱面，第0磁道，，第一扇区中读取被称为MBR的东西，即主引导记录。
* 第二步：一个扇区的大小是512字节，存放的是引导程序和分区信息，这些内容都是由专门的分区程序产生的。MBR中的引导程序是可以修改的，所以可以利用这个特性实现多操作系统共存。许多的linux系统会默认使用Grub作为引导程序，常见的是将Grup的地址写到MBR中（应为Grup太大了）。
* 第三步：运行Grup，根据其配置文件加载kernel镜像，并运行内核加载后第一个程序/sbin/init，这个程序回根据/etc/inittab来进行初始化的工作。
* 第四步：Linux将根据/etc/inittab中定义的系统初始化配置si::sysinit:/etc/rc.d/rc.sysinit执行/etc/rc.sysinit脚本，该脚本将会设置系统变量、网络配置，并配置swap、设定/proc、加载用户自定义模块、加载内核设置等。
* 第五步：根据第三步读到的runlevel值来启动对应的服务，如果值是3，就会运行/etc/rc3.d/下所有的脚本。
* 第六步：将运行/etc/rc.local
* 第七步：会生成终端或X Window来等待用户登录。

**runlevel系统运行级别**
> 0: 关机
> 
> 1: 单用户模式，系统出现问题时可使用这种模式进入系统维护（忘了root密码修改root密码）
> 
> 2: 多用户模式，没有网络连接
> 
> 3: 完全多用户模式
> 
> 4: 保留未使用
> 
> 5: 窗口模式，支持多用户，支持网络
> 
> 6: 重启

### Linux系统命令学习
  
* **使用帮助**
  
    **man** 命令,使用`man 命令`可以查看该命令的具体作用。man命令会对linux命令的说明文档分类。9种分类：
    * 常见命令说明
    * 可调用的系统
    * 函数库
    * 设备文件
    * 文件格式
    * 游戏说明
    * 杂项
    * 系统管理员可用的命令
    * 与内核相关等说明
  使用`man -f 命令`可是查看命令在不同分类中的说明

* **w**命令
    ```
    17:51  up 21 days,  8:11, 2 users, load averages: 1.93 1.99 2.05
    USER     TTY      FROM              LOGIN@  IDLE WHAT
    hddchange console  -                24Jan19 21days -
    hddchange s002     -                 9:48       - w
    登录用户名 登录终端  如果是网络登录，则显示主机名或ip  登录时间  闲置时间  与终端相关的当前所有运行进程消耗的CPU时间总量  当前WHAT列所对应的进程所消耗的CPU时间总量  当前运行的进程
    ```
* **su**
  
  su切换用户需要知道对应用户密码，su - 切换到对应用户环境
* **sudo**
  
  sudo命令切换不需要知道对应用户的密码，使用root权限执行。Linux在执行sudo命令的时候会去`/etc/sudoers`配置文件，查看当前用户是否有权限执行。
* **at** 单一时刻执行一次任务 
  
  `atq`查询任务，`atrm`删除任务

* **cron** 周期性执行任务

    **/etc/crontab**文件中设置有系统的周期任务

* **psd**现实当前目录

* **l**查看文件
```
drwxr-xr-x    6 root  wheel   192B Aug 18 07:17 wfs
```
  * 第一列：

    |第一个字符|含义|
    |---|---|
    |d|目录|
    |-|普通文件|
    |l|连接文件|
    |b|块文件|
    |c|字符文件|
    |s|socket文件|
    |p|管道文件|

    接下来每3个字符为 `r、w、x`的顺序组合，没有对应权限为`-`,第一个组合为所有者的权限，第二个组合为所有组的权限，第三个组合为其他用户的权限
  * 第二列：连接数
  * 第三列：文件所有人
  * 第四列：文件所有组
  * 第五列：文件大小
  * 第六列：文件最新修改时间
  * 第七列：文件名

* **chmod**修改文件权限
  文件所有者`u`、所属组`g`、其他人`o`,权限为 读`r` = 3、写`w` = 2、执行`x` = 1,s权限，t权限
  
  例：
    `chmod u+x 文件`就是给文件所有者授执行该文件的权限

    `chmod 700 文件`就是给文件所有者授权读写执行的权限，所有组和其他人不授任何权限

* **chown**更改文件所有者，同时更改文件所属组
* **chgrp**改变文件的拥有组
**查找文件**
* **find**一般查找
* **locate**
  使用前最好先执行一下`updatedb`命令
* **which/whereis**
**文件压缩/打包**
* **gzip/gunzip**
* **tar**
* **bzip2**
* **cpio**

### Linux系统用户管理
Linux系统的用户分为 `普通用户`、`根用户`（root用户）、`系统用户` ，Linux系统会使用`UID`来记录用户。

* **普通用户**的编号会从500往上，普通用户一般只能在其家目录、系统临时目录或其他经过授权的目录中操作，以及属于该用户的文件。
* **系统用户**的编号为1-499，系统用户是指系统运行时必须有的用户（并不是真正的使用者）。使用mysql这个系统用户运行mysqld进程就是使用系统用户。
* **root用户**的编号是0，对系统拥有完全的控制权。

在Linux系统中每个用户都必须至少属于一个`用户组`，Linux系统使用GID来标示用户组

**/etc/passwd**记录用户信息
这里只是简单介绍下passwd文件，这是linux系统很早之前的策略，将用户密码直接记录到这个文件上，随着时代发展，各个linux系统衍生版，都有自己的实现策略。
```shell
root:*:0:0:System Administrator:/var/root:/bin/sh
用户名：密码：UID：GID：说明：家目录：登录后执行的shell
```

### Linux文件管理
* **分区、文件系统、挂载、物理卷、逻辑卷、卷组、硬连接、软连接**
**FHS文件系统** 

|目录|用途|
|---|---|
|/bin|常见的用户指令|
|/boot|内核和启动文件|
|/dev|设备文件|
|/etc|系统和服务的配置文件|
|/home|系统默认的普通用户家目录|
|/lib|系统函数库目录|
|/lost+found|ext3文件系统需要的目录，用于磁盘检查|
|/mnt|系统加载文件系统时常用的挂载点|
|/opt|第三方软件安装目录|
|/proc|虚拟文件系统|
|/root|root用户的家目录|
|/sbin|存放系统管理命令|
|tmp|临时文件的存放目录|
|/usr|存放与用户直接相关的文件和目录|
|/media|系统用来挂载光驱等临时文件系统的挂载点

### 字符处理

#### 管道
在Linux系统中管道指的是指定大小的缓冲区（1页，4k字节）,我们可以使用`|`来连接进程，管道的表象为**输入输出的重定向**的一种方法。

例：
```shell
grep -C 3 -i exception error.log | less
```

文件字符命令
* **sort** 排序
* **uniq** 删除重复内容
* **cut** 截取文本
* **tr** 文本转换
* **paste** 文本合并
* **split** 分割大文件
* **awk** 文本处理工具
* **sed** 文本处理工具

### 网络管理
#### 网络名词
**网卡、路由、网关、DNS**
#### 配置文件
**/etc/hosts、/etc/resolv.conf**
#### 命令
**ifconfig、ping、host、traceroute**

### 进程管理
进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

进程的5种状态
![进程状态转换图](/img/doc_shell_01.png)

进程之间存在着**同步**或**互斥**的关系，现在计算机一般都是使用信号量机制来直线进程的通信，从而实现进程之间的**同步与互斥**。

#### 命令
* **ps**
  查看当前进程的瞬间的状态信息
* **top**
  动态及时的查看进程的状态信息

```shell

Processes: 286 total, 3 running, 1 stuck, 282 sleeping, 1918 threads                                                                                                                               01:02:02
Load Avg: 2.06, 1.84, 1.84  CPU usage: 11.66% user, 8.85% sys, 79.48% idle  SharedLibs: 132M resident, 48M data, 18M linkedit. MemRegions: 106912 total, 1984M resident, 59M private, 607M shared.
PhysMem: 7720M used (2290M wired), 470M unused. VM: 1783G vsize, 1297M framework vsize, 5156672(64) swapins, 5902321(0) swapouts.      Networks: packets: 4158928/2397M in, 3457000/435M out.
Disks: 1390495/33G read, 1046296/38G written.

PID    COMMAND      %CPU TIME     #TH   #WQ  #PORTS MEM    PURG   CMPRS  PGRP  PPID STATE    BOOSTS           %CPU_ME %CPU_OTHRS UID  FAULTS    COW     MSGSENT   MSGRECV   SYSBSD     SYSMACH   CSW
63464  top          12.9 00:01.40 1/1   0    25     5072K  0B     0B     63464 373  running  *0[1]            0.00000 0.00000    0    8050+     120     422778+   211361+   25947+     272610+   1171

```
> PID: 进程ID
> USER: 进程所有者
> PR: 进程优先级
> NI: nice值，负值表示高优先级，正值表示低优先级
> VIRT: 进程使用的虚拟内存总量，单位Kb，VIRT = SWAP + RES
> RES: 进程使用的未被换出点物理内存大小，单位为Kb，RES = CODE + DATA
> SHR: 共享内存大小，单位Kb
> %CPU: 上次更新到现在CPU时间占用百分比
> %MEM: 进程使用的物理内存百分比
> TIME+: 进程使用的CPU时间总计，单位1/100秒
> COMMAND: 进程名称（命令名/命令行）

#### 进程管理
**终止进程**
* **kill**
* **killall**
  
**查询进程打开的文件**
* **lsof**

**进程优先级调整**
* **nice**
* **renice**

**切换任务前后台：bg、fg、job、sctrl + z、ctrl + c、ctrl + \、ctrl + d**

1. &
加在一个命令的最后，可以把这个命令放到后台执行 ,如gftp &,
2. ctrl + z
可以将一个正在前台执行的命令放到后台，并且处于暂停状态，不可执行
3. jobs
查看当前有多少在后台运行的命令
jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息；
4. fg
将后台中的命令调至前台继续运行
如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)
5. bg
将一个在后台暂停的命令，变成继续执行 （在后台执行）
如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)
将任务转移到后台运行：
先ctrl + z；再bg，这样进程就被移到后台运行，终端还能继续接受命令。

### shell学习
shell的版本有很多种，现在主流了主要是bash shell，所以我学习主要以bash shell为主。

每个shell脚本开头的`#!/bin/bash`都是声名这个脚本解释器的位置

我们在写shell脚本的时候，可能会报错，这个时候我们可以`bash -x shell`命令，或在shell脚本中`echo 值`来查找问题。要是还是搞不定，我给大家安利一个好东西，**bashdb**脚本调试软件

#### Shell内建命令

在shell当中有很多的内建命令，内建命令不同于外部命令，内建命令的执行速度会比外部命令快很多，因为内建命令相当于shell里面的一个函数，不需要触及磁盘io就可以执行，使用**type**命令可以区分内建命令和外部命令。


**声明变量**：declare、typeset

shell中虽然有声明变量的命令，但是shell却是弱类型语言。

**转换字符串为shell命令**：eval

**结束循环**：break

**循环控制**：continue

**执行命令代替当前shell**：exec

**使用变量能被子shell识别**：export

**杀死进程**：kill

**整数运算**: let

**显示当前工作目录**: pwd

**声明局部变量**：local

**标准输入**：read

**定义函数返回值**: return

**显示并设置进程资源限度**: ulimit

**测试表达式**: test

#### Shell编程基础

**变量**

Shell中的变量都是弱类型的变量,主要分为两种`局部变量`、`环境变量`;

**局部变量**: 指只在当前shell中有效的变量

**环境变量**: 在当前环境中,所有的shell共享的变量
|变量名|用途|
|---|---|
|$0|	当前脚本的文件名|
|$n	|传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。|
|$#	|传递给脚本或函数的参数个数。|
|$*	|传递给脚本或函数的所有参数。|
|$@	|传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。|
|$?	|上个命令的退出状态，或函数的返回值。|
|$$|	当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。|

**变量赋值和取值**

Shell中变量的赋值中间不能拥有空格,变量值中空格时,必须用`"`或者`'`包起来

使用`${变量名}`来取值,这种方式是比较保险的做法

当变量值中引用的是其他变量,变量值必须使用`"`

**设置变量必须先声明再使用**: shopt -s -o nounset

**unset 变量名|函数名**: 取消变量或者函数

**数组**

数组的声明: declare -a 数组名 | 数组名={}

数组取值: ${数组名[ 索引 ]} , ${数组名[ * ]} 或 ${数组名[ @ ]}一次取出所有值

数组长度: 使用#号来获取字符串长度来获取数组长度,${#数组名[ * ]}、${#数组名[ @ ]}

截取数组: ${数组名[ @ ]:1:2},也可以截取其单个元素第某些字符

连接数组: 将若干第数组进行拼接操作, {$数组名[ @ ] ${数组名[ @ ]}}

替换元素: 将数组内莫个元素替换成其它值, Array=({$Array[ @ ]/要替换的值/被替换的值}]

取消数组或元素: unset

**只读变量**

只读变量又称为常量,是通过readonly命令创建的变量,声明时就要求赋值且无法修改, declare -r效果一样

Shell默认以Shell的进程ID作为一个命名空间,即使在函数中声明变量,该变量也会在全局生效.

`部分引用`: "" 在这种引用中 $ , ` , \ 这三种特殊字符都是有意义的

`全饮用`: '' 在这种引用中,所有字符都会当成普通的字符

`命令替换`: `` 或者 $() 将命令的标准输出作为值赋给莫个变量

**运算符**

算术运算符、位运算符、自增自减, 在shell中要给变量

`常规运算符`: 加(+)、减(-)、乘(*)、除(/)、余(%)、幂(**)

`复合运算符`: 加等(+=)、减等(-=)、乘等(*=)、除等(/=)、余等(%=)

`位运算符`: 左移(<<)、右移(>>)、

``:

``:

``:

``:

``:



























### shell常用脚本
#### shell判断命令是否存在
* command
  ```shell
    #! /bin/bash
    if command -v git >/dev/null 2>&1; then 
    echo 'exists git' 
    else 
    echo 'no exists git' 
    fi
  ```
* type
  ```shell
    #! /bin/bash
    if type git >/dev/null 2>&1; then 
    echo 'exists git' 
    else 
    echo 'no exists git' 
    fi
  ```
* hash
  ```shell
    #! /bin/bash
    if hash git 2>/dev/null; then 
    echo 'exists git' 
    else 
    echo 'no exists git' 
    fi
  ```
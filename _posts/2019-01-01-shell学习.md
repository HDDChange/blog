---
layout:     post
title:      Shell学习
subtitle:   shell学习之路
date:       2019-01-01
author:     HDD
header-img: img/post_bg_shell.png
catalog: true
tags:
    - shell
---

# 前言
在前段时间工作都时候，因为公司测试环境需要测试其他模块，而我这一块的功能由于默写原因不能合并到里面。所以我需要自己在服务器上搭建一套测试环境，开始接触到了shell，之前也用过ubuntu做为过个人操作系统，但是并没有系统的学习过Linux和shell（虽然学校教过），所以在这里记录一下自己学习shell的心得。

### Linux系统启动流程
* 第一步：首先BIOS系统会加电自检（主要检查硬件有没有问题），然后BIOS系统会引导系统，BIOS默认回从硬盘上的第0柱面，第0磁道，，第一扇区中读取被称为MBR的东西，即主引导记录。
* 第二步：一个扇区的大小是512字节，存放的是引导程序和分区信息，这些内容都是由专门的分区程序产生的。MBR中的引导程序是可以修改的，所以可以利用这个特性实现多操作系统共存。许多的linux系统会默认使用Grub作为引导程序，常见的是将Grup的地址写到MBR中（应为Grup太大了）。
* 第三步：运行Grup，根据其配置文件加载kernel镜像，并运行内核加载后第一个程序/sbin/init，这个程序回根据/etc/inittab来进行初始化的工作。
* 第四步：Linux将根据/etc/inittab中定义的系统初始化配置si::sysinit:/etc/rc.d/rc.sysinit执行/etc/rc.sysinit脚本，该脚本将会设置系统变量、网络配置，并配置swap、设定/proc、加载用户自定义模块、加载内核设置等。
* 第五步：根据第三步读到的runlevel值来启动对应的服务，如果值是3，就会运行/etc/rc3.d/下所有的脚本。
* 第六步：将运行/etc/rc.local
* 第七步：会生成终端或X Window来等待用户登录。

**runlevel系统运行级别**
> 0: 关机
> 
> 1: 单用户模式，系统出现问题时可使用这种模式进入系统维护（忘了root密码修改root密码）
> 
> 2: 多用户模式，没有网络连接
> 
> 3: 完全多用户模式
> 
> 4: 保留未使用
> 
> 5: 窗口模式，支持多用户，支持网络
> 
> 6: 重启

### Linux系统命令学习
  
* **使用帮助**
  
    **man** 命令,使用`man 命令`可以查看该命令的具体作用。man命令会对linux命令的说明文档分类。9种分类：
    * 常见命令说明
    * 可调用的系统
    * 函数库
    * 设备文件
    * 文件格式
    * 游戏说明
    * 杂项
    * 系统管理员可用的命令
    * 与内核相关等说明
  使用`man -f 命令`可是查看命令在不同分类中的说明

* **w**命令
    ```
    17:51  up 21 days,  8:11, 2 users, load averages: 1.93 1.99 2.05
    USER     TTY      FROM              LOGIN@  IDLE WHAT
    hddchange console  -                24Jan19 21days -
    hddchange s002     -                 9:48       - w
    登录用户名 登录终端  如果是网络登录，则显示主机名或ip  登录时间  闲置时间  与终端相关的当前所有运行进程消耗的CPU时间总量  当前WHAT列所对应的进程所消耗的CPU时间总量  当前运行的进程
    ```
* **su**
  
  su切换用户需要知道对应用户密码，su - 切换到对应用户环境
* **sudo**
  
  sudo命令切换不需要知道对应用户的密码，使用root权限执行。Linux在执行sudo命令的时候会去`/etc/sudoers`配置文件，查看当前用户是否有权限执行。
* **at** 单一时刻执行一次任务 
  
  `atq`查询任务，`atrm`删除任务

* **cron** 周期性执行任务

    **/etc/crontab**文件中设置有系统的周期任务

* **psd**现实当前目录

* **l**查看文件
```
drwxr-xr-x    6 root  wheel   192B Aug 18 07:17 wfs
```
  * 第一列：

    |第一个字符|含义|
    |---|---|
    |d|目录|
    |-|普通文件|
    |l|连接文件|
    |b|块文件|
    |c|字符文件|
    |s|socket文件|
    |p|管道文件|

    接下来每3个字符为 `r、w、x`的顺序组合，没有对应权限为`-`,第一个组合为所有者的权限，第二个组合为所有组的权限，第三个组合为其他用户的权限
  * 第二列：连接数
  * 第三列：文件所有人
  * 第四列：文件所有组
  * 第五列：文件大小
  * 第六列：文件最新修改时间
  * 第七列：文件名

* **chmod**修改文件权限
  文件所有者`u`、所属组`g`、其他人`o`,权限为 读`r` = 3、写`w` = 2、执行`x` = 1,s权限，t权限
  
  例：
    `chmod u+x 文件`就是给文件所有者授执行该文件的权限

    `chmod 700 文件`就是给文件所有者授权读写执行的权限，所有组和其他人不授任何权限

* **chown**更改文件所有者，同时更改文件所属组
* **chgrp**改变文件的拥有组
**查找文件**
* **find**一般查找
* **locate**
  使用前最好先执行一下`updatedb`命令
* **which/whereis**
**文件压缩/打包**
* **gzip/gunzip**
* **tar**
* **bzip2**
* **cpio**

### Linux系统用户管理
Linux系统的用户分为 `普通用户`、`根用户`（root用户）、`系统用户` ，Linux系统会使用`UID`来记录用户。

* **普通用户**的编号会从500往上，普通用户一般只能在其家目录、系统临时目录或其他经过授权的目录中操作，以及属于该用户的文件。
* **系统用户**的编号为1-499，系统用户是指系统运行时必须有的用户（并不是真正的使用者）。使用mysql这个系统用户运行mysqld进程就是使用系统用户。
* **root用户**的编号是0，对系统拥有完全的控制权。

在Linux系统中每个用户都必须至少属于一个`用户组`，Linux系统使用GID来标示用户组

**/etc/passwd**记录用户信息
这里只是简单介绍下passwd文件，这是linux系统很早之前的策略，将用户密码直接记录到这个文件上，随着时代发展，各个linux系统衍生版，都有自己的实现策略。
```shell
root:*:0:0:System Administrator:/var/root:/bin/sh
用户名：密码：UID：GID：说明：家目录：登录后执行的shell
```

### Linux文件管理
* **分区、文件系统、挂载、物理卷、逻辑卷、卷组、硬连接、软连接**
**FHS文件系统** 

|目录|用途|
|---|---|
|/bin|常见的用户指令|
|/boot|内核和启动文件|
|/dev|设备文件|
|/etc|系统和服务的配置文件|
|/home|系统默认的普通用户家目录|
|/lib|系统函数库目录|
|/lost+found|ext3文件系统需要的目录，用于磁盘检查|
|/mnt|系统加载文件系统时常用的挂载点|
|/opt|第三方软件安装目录|
|/proc|虚拟文件系统|
|/root|root用户的家目录|
|/sbin|存放系统管理命令|
|tmp|临时文件的存放目录|
|/usr|存放与用户直接相关的文件和目录|
|/media|系统用来挂载光驱等临时文件系统的挂载点

### 字符处理

#### 管道
在Linux系统中管道指的是指定大小的缓冲区（1页，4k字节）,我们可以使用`|`来连接进程，管道的表象为**输入输出的重定向**的一种方法。

例：
```shell
grep -C 3 -i exception error.log | less
```

文件字符命令
* **sort** 排序
* **uniq** 删除重复内容
* **cut** 截取文本
* **tr** 文本转换
* **paste** 文本合并
* **split** 分割大文件

### 网络管理
#### 网络名词
**网卡、路由、网关、DNS**
#### 配置文件
**/etc/hosts、/etc/resolv.conf**
#### 命令
**ifconfig、ping、host、traceroute**

### 进程管理
进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

进程的5种状态
![进程状态转换图](/img/doc_shell_01.png)

进程之间存在着**同步**或**互斥**的关系，现在计算机一般都是使用信号量机制来直线进程的通信，从而实现进程之间的**同步与互斥**。

#### 命令
* **ps**
  查看当前进程的瞬间的状态信息
* **top**
  动态及时的查看进程的状态信息

```shell

Processes: 286 total, 3 running, 1 stuck, 282 sleeping, 1918 threads                                                                                                                               01:02:02
Load Avg: 2.06, 1.84, 1.84  CPU usage: 11.66% user, 8.85% sys, 79.48% idle  SharedLibs: 132M resident, 48M data, 18M linkedit. MemRegions: 106912 total, 1984M resident, 59M private, 607M shared.
PhysMem: 7720M used (2290M wired), 470M unused. VM: 1783G vsize, 1297M framework vsize, 5156672(64) swapins, 5902321(0) swapouts.      Networks: packets: 4158928/2397M in, 3457000/435M out.
Disks: 1390495/33G read, 1046296/38G written.

PID    COMMAND      %CPU TIME     #TH   #WQ  #PORTS MEM    PURG   CMPRS  PGRP  PPID STATE    BOOSTS           %CPU_ME %CPU_OTHRS UID  FAULTS    COW     MSGSENT   MSGRECV   SYSBSD     SYSMACH   CSW
63464  top          12.9 00:01.40 1/1   0    25     5072K  0B     0B     63464 373  running  *0[1]            0.00000 0.00000    0    8050+     120     422778+   211361+   25947+     272610+   1171

```
> PID: 进程ID
> USER: 进程所有者
> PR: 进程优先级
> NI: nice值，负值表示高优先级，正值表示低优先级
> VIRT: 进程使用的虚拟内存总量，单位Kb，VIRT = SWAP + RES
> RES: 进程使用的未被换出点物理内存大小，单位为Kb，RES = CODE + DATA
> SHR: 共享内存大小，单位Kb
> %CPU: 上次更新到现在CPU时间占用百分比
> %MEM: 进程使用的物理内存百分比
> TIME+: 进程使用的CPU时间总计，单位1/100秒
> COMMAND: 进程名称（命令名/命令行）

#### 进程管理
**终止进程**
* **kill**
* **killall**
  
**查询进程打开的文件**
* **lsof**

**进程优先级调整**
* **nice**
* **renice**







### shell常用脚本
#### shell判断命令是否存在
* command
  ```shell
    #! /bin/bash
    if command -v git >/dev/null 2>&1; then 
    echo 'exists git' 
    else 
    echo 'no exists git' 
    fi
  ```
* type
  ```shell
    #! /bin/bash
    if type git >/dev/null 2>&1; then 
    echo 'exists git' 
    else 
    echo 'no exists git' 
    fi
  ```
* hash
  ```shell
    #! /bin/bash
    if hash git 2>/dev/null; then 
    echo 'exists git' 
    else 
    echo 'no exists git' 
    fi
  ```